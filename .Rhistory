return(raster)
}
#' Raster crop
#'
#' @param raster a terra SpatRaster to be cropped
#' @param type either data raster or reference raster
#' @param roi Region Of Interest: cropping extent
#'
#' @return a terra SpatRaster cropped to ROI
#' @export
#'
#' @description Crop SpatRaster to large ROI (entire core)
#' For capture (core) SpatRaster use full extent
#' For reference (white and dark) SpatRaster use only x-direction
#'
#' @examples
raster_crop <- function(raster, type, roi) {
# If cropping entire capture SpatRaster use entire large ROI
if (type == "capture") {
raster <- terra::crop(raster, roi)
# If cropping reference SpatRaster use only xmin and xmax from large ROI
} else {
raster <- terra::crop(raster, c(terra::xmin(roi), terra::xmax(roi), terra::ymin(raster), terra::ymax(raster)), filename = here::here("products/capture_cropped.tif"), overwrite = TRUE)
}
# Return raster
return(raster)
}
#' Create reference raster
#'
#' @param raster a terra SpatRaster of the captured reference
#' @param roi Region Of Interest: extent to match data raster
#'
#' @return a terra SpatRaster of reference matching the data raster extent
#' @export
#'
#' @description Creating reference SpatRaster covering core extent
#' Create one mean reference row SpatRaster by averaging data every column by aggregation
#' Create reference SpatRaster matching capture SpatRaster extent by disaggregation
#'
#' @examples
create_reference_raster <- function(raster, roi) {
# Aggregate data into one row SpatRaster, divide by number of rows
raster <- terra::aggregate(raster, fact = c(terra::nrow(raster), 1), fun = "mean", filename = here::here("products/ref_agg_tmp.tif"), overwrite = TRUE)
# Set new extent to match extent of capture SpatRaster
terra::ext(raster) <- roi
# Disaggregate data over entire extent to mach capture SpatRaster extent, multiply by ymax
raster <- terra::disagg(raster, fact = c(terra::ymax(raster), 1), filename = here::here("products/ref_disagg_tmp.tif"), overwrite = TRUE)
# Return raster
return(raster)
}
#' Raster normalization: calculation
#'
#' @param capture a terra SpatRaster of captured data
#' @param whiteref a terra SpatRaster of the white reference matching capture extent
#' @param darkref a terra SpatRaster of the dark reference matching capture extent
#'
#' @return a normalized terra SpatRaster of the capture
#' @export
#'
#' @description normalize captured hyperspectral data with white and dark reference according to equation from Butz et al 2016
#'
#' @examples
normalization <- function(capture = capture, whiteref = whiteref, darkref = darkref) {
# Calculate numenator (above the bar)
numenator <- capture - darkref
# Coerce NA to 0
numenator[is.na(numenator)] <- 0
# Coerce negative values to 0
numenator[numenator < 0] <- 0
# Calculate denominator (below the bar)
denominator <- whiteref - darkref
# Normalize
raster <- numenator / denominator
# Return raster
return(raster)
}
#' Raster normalization
#'
#' @param capture a terra SpatRaster of captured data
#' @param whiteref a terra SpatRaster of the white reference matching capture extent
#' @param darkref a terra SpatRaster of the dark reference matching capture extent
#' @param fun function to apply: normalization
#'
#' @return a normalized terra SpatRaster of the capture
#' @export
#'
#' @description apply normalization function over the combination of capture and reference SpatRasters using terra spatial dataset
#'
#' @examples
create_normalized_raster <- function(capture = capture, whiteref = whiteref, darkref = darkref, fun = normalization) {
# Create terra spatial dataset combining SpatRasters
# Create list
dataset <- list(capture, whiteref, darkref) |>
# Create terra dataset
terra::sds()
# Apply function over the dataset and write to file
raster <- terra::lapp(x = dataset, fun = fun, overwrite = TRUE, filename = here::here("products/capture_normalized.tif"), overwrite = TRUE)
}
################################################################################
#                                                         Normalization workflow
spectra <- c(550, 570, 590, 615, 630, 649:701, 730, 790, 845, 900)
"~"
fs::path("~~")
fs::path("~")
fs::dir_ls("~")
################################################################################
#                                                         Normalization workflow
spectra <- c(550, 570, 590, 615, 630, 649:701, 730, 790, 845, 900)
capture <- terra::rast("C:/GitHub/STL14_1A_28C_top_2022-11-11_16-30-51/capture/STL14_1A_28C_top_2022-11-11_16-30-51.raw")
big_roi <- terra::ext(c(110, 1010, 0, 16000))
capture <- spectra_position(raster = capture, spectra = spectra) |>
spectra_sub(raster = capture, spectra_tbl = _) |>
raster_crop(raster = _, type = "capture", roi = big_roi)
here::here()
View(raster_crop)
#' @param roi Region Of Interest: cropping extent
#'
#' @return a terra SpatRaster cropped to ROI
#' @export
#'
#' @description Crop SpatRaster to large ROI (entire core)
#' For capture (core) SpatRaster use full extent
#' For reference (white and dark) SpatRaster use only x-direction
#'
#' @examples
raster_crop <- function(raster, type, roi) {
# If cropping entire capture SpatRaster use entire large ROI
if (type == "capture") {
raster <- terra::crop(raster, roi, filename = here::here("products/capture_cropped.tif"), overwrite = TRUE)
# If cropping reference SpatRaster use only xmin and xmax from large ROI
} else {
raster <- terra::crop(raster, c(terra::xmin(roi), terra::xmax(roi), terra::ymin(raster), terra::ymax(raster)), filename = paste0(here::here("products/"), Sys.time(), "capture_cropped.tif"), overwrite = TRUE)
}
# Return raster
return(raster)
}
capture <- spectra_position(raster = capture, spectra = spectra) |>
spectra_sub(raster = capture, spectra_tbl = _) |>
raster_crop(raster = _, type = "capture", roi = big_roi)
#' @param roi Region Of Interest: cropping extent
#'
#' @return a terra SpatRaster cropped to ROI
#' @export
#'
#' @description Crop SpatRaster to large ROI (entire core)
#' For capture (core) SpatRaster use full extent
#' For reference (white and dark) SpatRaster use only x-direction
#'
#' @examples
raster_crop <- function(raster, type, roi) {
# If cropping entire capture SpatRaster use entire large ROI
if (type == "capture") {
raster <- terra::crop(raster, roi, filename = here::here("products/capture_cropped.tif"), overwrite = TRUE)
# If cropping reference SpatRaster use only xmin and xmax from large ROI
} else {
raster <- terra::crop(raster, c(terra::xmin(roi), terra::xmax(roi), terra::ymin(raster), terra::ymax(raster)), filename = paste0(here::here("products/"), Sys.time(), "_capture_cropped.tif"), overwrite = TRUE)
}
# Return raster
return(raster)
}
capture <- spectra_position(raster = capture, spectra = spectra) |>
spectra_sub(raster = capture, spectra_tbl = _) |>
raster_crop(raster = _, type = "capture", roi = big_roi)
filename = paste0(here::here("products/"), Sys.time())
filename
Sys.time()
timestamp()
##------ Tue Jan 31 13:46:15 2023 ------##
format(system.time())
format(Sys.time()
format(Sys.time())
paste0(here::here("products/"), "/", Sys.time(), "_capture_cropped.tif")
here::here("products/capture_cropped.tif")
here::set_here("C:/GitHub/STL14_1A_28C_top_2022-11-11_16-30-51")
here
here::here()
################################################################################
#                                                         Normalization workflow
# Set path so directory so temporary raster and other files are written
# Later subsitute with path selected interactivelly with get_paths
paths[["directory"]] <- "C:/GitHub/STL14_1A_28C_top_2022-11-11_16-30-51/"
################################################################################
#                                                         Normalization workflow
# Set path so directory so temporary raster and other files are written
# Later subsitute with path selected interactivelly with get_paths
paths <- list()
paths[["directory"]] <- "C:/GitHub/STL14_1A_28C_top_2022-11-11_16-30-51/"
paste0(paths[["directory"]], "products/", Sys.time(), "_capture_cropped.tif")
paste0(paths[["directory"]], "products/capture_cropped.tif")
#' @param roi Region Of Interest: cropping extent
#'
#' @return a terra SpatRaster cropped to ROI
#' @export
#'
#' @description Crop SpatRaster to large ROI (entire core)
#' For capture (core) SpatRaster use full extent
#' For reference (white and dark) SpatRaster use only x-direction
#'
#' @examples
raster_crop <- function(raster, type, roi) {
# If cropping entire capture SpatRaster use entire large ROI
if (type == "capture") {
raster <- terra::crop(raster, roi, filename = paste0(paths[["directory"]], "products/capture_cropped.tif"), overwrite = TRUE)
# If cropping reference SpatRaster use only xmin and xmax from large ROI
} else {
raster <- terra::crop(raster, c(terra::xmin(roi), terra::xmax(roi), terra::ymin(raster), terra::ymax(raster)), filename = paste0(paths[["directory"]], "products/", Sys.time(), "_capture_cropped.tif"), overwrite = TRUE)
}
# Return raster
return(raster)
}
spectra <- c(550, 570, 590, 615, 630, 649:701, 730, 790, 845, 900)
capture <- terra::rast("C:/GitHub/STL14_1A_28C_top_2022-11-11_16-30-51/capture/STL14_1A_28C_top_2022-11-11_16-30-51.raw")
big_roi <- terra::ext(c(110, 1010, 0, 16000))
capture <- spectra_position(raster = capture, spectra = spectra) |>
spectra_sub(raster = capture, spectra_tbl = _) |>
raster_crop(raster = _, type = "capture", roi = big_roi)
whiteref <- terra::rast("C:/GitHub/STL14_1A_28C_top_2022-11-11_16-30-51/capture/WHITEREF_STL14_1A_28C_top_2022-11-11_16-30-51.raw")
whiteref <- spectra_position(raster = whiteref, spectra = spectra) |>
spectra_sub(raster = whiteref, spectra_tbl = _) |>
raster_crop(raster = _, type = "reference", roi = big_roi) |>
create_reference_raster(raster = _, roi = big_roi)
#' @examples
#' @param roi Region Of Interest: cropping extent
#'
#' @return a terra SpatRaster cropped to ROI
#' @export
#'
#' @description Crop SpatRaster to large ROI (entire core)
#' For capture (core) SpatRaster use full extent
#' For reference (white and dark) SpatRaster use only x-direction
#'
#' @examples
raster_crop <- function(raster, type, roi, ref_type) {
# If cropping entire capture SpatRaster use entire large ROI
if (type == "capture") {
raster <- terra::crop(raster, roi, filename = paste0(paths[["directory"]], "products/capture_cropped.tif"), overwrite = TRUE)
# If cropping reference SpatRaster use only xmin and xmax from large ROI
} else if (ref_type == "whiteref"){
raster <- terra::crop(raster, c(terra::xmin(roi), terra::xmax(roi), terra::ymin(raster), terra::ymax(raster)), filename = paste0(paths[["directory"]], "products/", "_whiteref_cropped.tif"), overwrite = TRUE)
} else {
raster <- terra::crop(raster, c(terra::xmin(roi), terra::xmax(roi), terra::ymin(raster), terra::ymax(raster)), filename = paste0(paths[["directory"]], "products/", "_darkref_cropped.tif"), overwrite = TRUE)
}
# Return raster
return(raster)
}
whiteref <- spectra_position(raster = whiteref, spectra = spectra) |>
spectra_sub(raster = whiteref, spectra_tbl = _) |>
raster_crop(raster = _, type = "reference", roi = big_roi, ref_type = "whiteref") |>
create_reference_raster(raster = _, roi = big_roi)
#' @param roi Region Of Interest: cropping extent
#'
#' @return a terra SpatRaster cropped to ROI
#' @export
#'
#' @description Crop SpatRaster to large ROI (entire core)
#' For capture (core) SpatRaster use full extent
#' For reference (white and dark) SpatRaster use only x-direction
#'
#' @examples
raster_crop <- function(raster, type, roi, ref_type) {
# If cropping entire capture SpatRaster use entire large ROI
if (type == "capture") {
raster <- terra::crop(raster, roi, filename = paste0(paths[["directory"]], "products/capture_cropped.tif"), overwrite = TRUE)
# If cropping reference SpatRaster use only xmin and xmax from large ROI
} else if (ref_type == "whiteref"){
raster <- terra::crop(raster, c(terra::xmin(roi), terra::xmax(roi), terra::ymin(raster), terra::ymax(raster)), filename = paste0(paths[["directory"]], "products/_whiteref_cropped.tif"), overwrite = TRUE)
} else {
raster <- terra::crop(raster, c(terra::xmin(roi), terra::xmax(roi), terra::ymin(raster), terra::ymax(raster)), filename = paste0(paths[["directory"]], "products/_darkref_cropped.tif"), overwrite = TRUE)
}
# Return raster
return(raster)
}
whiteref <- spectra_position(raster = whiteref, spectra = spectra) |>
spectra_sub(raster = whiteref, spectra_tbl = _) |>
raster_crop(raster = _, type = "reference", roi = big_roi, ref_type = "whiteref") |>
create_reference_raster(raster = _, roi = big_roi)
paste0(paths[["directory"]], "products/_whiteref_cropped.tif")
#' @param roi Region Of Interest: cropping extent
#'
#' @return a terra SpatRaster cropped to ROI
#' @export
#'
#' @description Crop SpatRaster to large ROI (entire core)
#' For capture (core) SpatRaster use full extent
#' For reference (white and dark) SpatRaster use only x-direction
#'
#' @examples
raster_crop <- function(raster, type, roi, ref_type) {
# If cropping entire capture SpatRaster use entire large ROI
if (type == "capture") {
raster <- terra::crop(raster, roi, filename = paste0(paths[["directory"]], "products/capture_cropped.tif"), overwrite = TRUE)
# If cropping reference SpatRaster use only xmin and xmax from large ROI
} else if (ref_type == "whiteref"){
raster <- terra::crop(raster, c(terra::xmin(roi), terra::xmax(roi), terra::ymin(raster), terra::ymax(raster)), filename = paste0(paths[["directory"]], "products/whiteref_cropped.tif"), overwrite = TRUE)
} else {
raster <- terra::crop(raster, c(terra::xmin(roi), terra::xmax(roi), terra::ymin(raster), terra::ymax(raster)), filename = paste0(paths[["directory"]], "products/darkref_cropped.tif"), overwrite = TRUE)
}
# Return raster
return(raster)
}
whiteref <- spectra_position(raster = whiteref, spectra = spectra) |>
spectra_sub(raster = whiteref, spectra_tbl = _) |>
raster_crop(raster = _, type = "reference", roi = big_roi, ref_type = "whiteref") |>
create_reference_raster(raster = _, roi = big_roi)
whiteref
#' @param roi Region Of Interest: extent to match data raster
#'
#' @return a terra SpatRaster of reference matching the data raster extent
#' @export
#'
#' @description Creating reference SpatRaster covering core extent
#' Create one mean reference row SpatRaster by averaging data every column by aggregation
#' Create reference SpatRaster matching capture SpatRaster extent by disaggregation
#'
#' @examples
create_reference_raster <- function(raster, roi, ref_type) {
if (ref_type == "whiteref"){
name <- "whiteref"
} else {
name <- "darkref"
}
# Aggregate data into one row SpatRaster, divide by number of rows
raster <- terra::aggregate(raster, fact = c(terra::nrow(raster), 1), fun = "mean", filename = paste0(paths[["directory"]], "products/", name, "_agg.tif"), overwrite = TRUE)
# Set new extent to match extent of capture SpatRaster
terra::ext(raster) <- roi
# Disaggregate data over entire extent to mach capture SpatRaster extent, multiply by ymax
raster <- terra::disagg(raster, fact = c(terra::ymax(raster), 1), filename = paste0(paths[["directory"]], "products/", name, "_disagg.tif"), overwrite = TRUE)
# Return raster
return(raster)
}
whiteref <- terra::rast("C:/GitHub/STL14_1A_28C_top_2022-11-11_16-30-51/capture/WHITEREF_STL14_1A_28C_top_2022-11-11_16-30-51.raw")
whiteref <- spectra_position(raster = whiteref, spectra = spectra) |>
spectra_sub(raster = whiteref, spectra_tbl = _) |>
raster_crop(raster = _, type = "reference", roi = big_roi, ref_type = "whiteref") |>
create_reference_raster(raster = _, roi = big_roi, ref_type = "whiteref")
darkref <- terra::rast("C:/GitHub/STL14_1A_28C_top_2022-11-11_16-30-51/capture/DARKREF_STL14_1A_28C_top_2022-11-11_16-30-51.raw")
darkref <- spectra_position(raster = darkref, spectra = spectra) |>
spectra_sub(raster = darkref, spectra_tbl = _) |>
raster_crop(raster = _, type = "reference", roi = big_roi) |>
create_reference_raster(raster = _, roi = big_roi)
darkref <- spectra_position(raster = darkref, spectra = spectra) |>
spectra_sub(raster = darkref, spectra_tbl = _) |>
raster_crop(raster = _, type = "reference", roi = big_roi, ref_type = "darkref") |>
create_reference_raster(raster = _, roi = big_roi, ref_type = "darkref")
#' @param whiteref a terra SpatRaster of the white reference matching capture extent
#' @param darkref a terra SpatRaster of the dark reference matching capture extent
#' @param fun function to apply: normalization
#'
#' @return a normalized terra SpatRaster of the capture
#' @export
#'
#' @description apply normalization function over the combination of capture and reference SpatRasters using terra spatial dataset
#'
#' @examples
create_normalized_raster <- function(capture = capture, whiteref = whiteref, darkref = darkref, fun = normalization) {
# Create terra spatial dataset combining SpatRasters
# Create list
dataset <- list(capture, whiteref, darkref) |>
# Create terra dataset
terra::sds()
# Apply function over the dataset and write to file
raster <- terra::lapp(x = dataset, fun = fun, overwrite = TRUE, filename = paste0(paths[["directory"]], "products/capture_normalized.tif"), overwrite = TRUE)
}
normalized <- create_normalized_raster(capture = capture, whiteref = whiteref, darkref = darkref, fun = normalization)
#' @param whiteref a terra SpatRaster of the white reference matching capture extent
#' @param darkref a terra SpatRaster of the dark reference matching capture extent
#' @param fun function to apply: normalization
#'
#' @return a normalized terra SpatRaster of the capture
#' @export
#'
#' @description apply normalization function over the combination of capture and reference SpatRasters using terra spatial dataset
#'
#' @examples
create_normalized_raster <- function(capture = capture, whiteref = whiteref, darkref = darkref, fun = normalization) {
# Create terra spatial dataset combining SpatRasters
# Create list
dataset <- list(capture, whiteref, darkref) |>
# Create terra dataset
terra::sds()
# Apply function over the dataset and write to file
raster <- terra::lapp(x = dataset, fun = fun, filename = paste0(paths[["directory"]], "products/capture_normalized.tif"), overwrite = TRUE)
}
normalized <- create_normalized_raster(capture = capture, whiteref = whiteref, darkref = darkref, fun = normalization)
terra::rast("C:/GitHub/STL14_1A_28C_top_2022-11-11_16-30-51/capture/STL14_1A_28C_top_2022-11-11_16-30-51.raw")
test <- terra::rast("C:/GitHub/STL14_1A_28C_top_2022-11-11_16-30-51/capture/STL14_1A_28C_top_2022-11-11_16-30-51.raw")
names(test)
names(test) |> as.numeric()
names(test) |> as.numeric() |> \(x) x - dplyr::lead(x)()
names(test) |> as.numeric() |> \(x) x - dplyr::lead(x)(){}
new <- names(test) |> as.numeric()
new - dplyr::lead(new)
(new - dplyr::lag(new)) |> mean(, na.rm = TRUE)
install.packages(c("gratia", "janitor"))
EMMAgeo::EMMA()
EMMAgeo::GUI()
vroom::vroom("C:/Users/maury/Downloads/2023-02-02_EK-EK14_grainsize.csv") |> janitor::clean_names()
test <- vroom::vroom("C:/Users/maury/Downloads/2023-02-02_EK-EK14_grainsize.csv") |> janitor::clean_names()
View(test)
test <- vroom::vroom("C:/Users/maury/Downloads/2023-02-02_EK-EK14_grainsize.csv", locale = locale("PL")) |> janitor::clean_names()
test <- vroom::vroom("C:/Users/maury/Downloads/2023-02-02_EK-EK14_grainsize.csv", locale = "PL") |> janitor::clean_names()
test <- readxl::read_excel("C:/Users/maury/Downloads/2023-02-02_EK-EK14_grainsize.xlsx") |> janitor::clean_names()
View(test)
test <- vroom::vroom("C:/Users/maury/Downloads/2023-02-02_EK-EK14_grainsize.csv", locale = "pl") |> janitor::clean_names()
vroom::locale("pl")
test <- vroom::vroom("C:/Users/maury/Downloads/2023-02-02_EK-EK14_grainsize.csv", locale = vroom::locale("pl")) |> janitor::clean_names()
test <- readxl::read_excel("C:/Users/maury/Downloads/2023-02-02_EK-EK14_grainsize.xlsx") |> janitor::clean_names()
View(test)
test <- readxl::read_excel("C:/Users/maury/Downloads/2023-02-02_EK-EK14_grainsize.xlsx") |> janitor::clean_names() |> readr::write_rds("C:/Users/maury/Downloads/2023-02-02_EK-EK14_grainsize.rds")
capture <- terra::rast("C:/Users/maury/Downloads/STL14_1A_28C_top_2022-11-11_16-30-51/capture/STL14_1A_28C_top_2022-11-11_16-30-51.raw")
capture <- terra::rast("C:/Users/maury/Downloads/STL14_1A_28C_top_2022-11-11_16-30-51/capture/STL14_1A_28C_top_2022-11-11_16-30-51.raw")
spectra <- c(550, 570, 590, 615, 630, 649:701, 730, 790, 845, 900)
capture <- terra::rast("C:/GitHub/STL14_1A_28C_top_2022-11-11_16-30-51/capture/STL14_1A_28C_top_2022-11-11_16-30-51.raw")
names(capture)
#' @param spectra vector with choice of desired spectra
#'
#' @return positions (indices) of desired spectra in SpatRaster
#' @export
#'
#' @description find index position of the nearest spectra (band) in the dataset.
#' Match for the lowest difference between integer band and actual SpatRaster band.
#' This will produce duplicates with multiple bands. Drop.
#'
#' @examples
spectra_position <- function(raster, spectra) {
# Find index (position) of selected spectra by comparing choice and names
spectraIndex <- purrr::map(spectra, \(x) which.min(abs(x - as.numeric(names(raster))))) |>
# Get positions
purrr::as_vector()
# Create tibble with spectra of choice and respective position
spectraIndex <- dplyr::tibble(
spectra = spectra,
position = spectraIndex) |>
# Group by position
dplyr::group_by(position) |>
# Keep second observation if duplicates are present
# From experience closer to desired product
dplyr::slice_tail()
# Return values
return(spectraIndex)
}
spectra <- c(550, 570, 590, 615, 630, 649:701, 730, 790, 845, 900)
whiteref <- terra::rast("C:/GitHub/STL14_1A_28C_top_2022-11-11_16-30-51/capture/WHITEREF_STL14_1A_28C_top_2022-11-11_16-30-51.raw")
show(whiteref)
#' @param spectra vector with choice of desired spectra
#'
#' @return positions (indices) of desired spectra in SpatRaster
#' @export
#'
#' @description find index position of the nearest spectra (band) in the dataset.
#' Match for the lowest difference between integer band and actual SpatRaster band.
#' This will produce duplicates with multiple bands. Drop.
#'
#' @examples
spectra_position <- function(raster, spectra) {
# Find index (position) of selected spectra by comparing choice and names
spectraIndex <- purrr::map(spectra, \(x) which.min(abs(x - as.numeric(names(raster))))) |>
# Get positions
purrr::as_vector()
# Create tibble with spectra of choice and respective position
spectraIndex <- dplyr::tibble(
spectra = spectra,
position = spectraIndex) |>
# Group by position
dplyr::group_by(position) |>
# Keep second observation if duplicates are present
# From experience closer to desired product
dplyr::slice_tail()
# Return values
return(spectraIndex)
}
spectra <- c(550, 570, 590, 615, 630, 649:701, 730, 790, 845, 900)
whiteref <- terra::rast("C:/GitHub/STL14_1A_28C_top_2022-11-11_16-30-51/capture/WHITEREF_STL14_1A_28C_top_2022-11-11_16-30-51.raw")
spectraIndex <- spectra |>
purrr::map(spectra, \(x) which.min(abs(x - as.numeric(names(whiteref))))) |>
# Get positions
purrr::as_vector()
spectra_position <- function(raster, spectra) {
# Find index (position) of selected spectra by comparing choice and names
spectraIndex <- purrr::map(spectra, \(x) which.min(abs(x - as.numeric(names(raster))))) |>
# Get positions
purrr::as_vector()
# Create tibble with spectra of choice and respective position
spectraIndex <- dplyr::tibble(
spectra = spectra,
position = spectraIndex) |>
# Group by position
dplyr::group_by(position) |>
# Keep second observation if duplicates are present
# From experience closer to desired product
dplyr::slice_tail()
# Return values
return(spectraIndex)
}
spectra_position(whiteref, spectra)
spectraIndex <- spectra |>
purrr::map(\(x) which.min(abs(x - as.numeric(names(whiteref))))) |>
# Get positions
purrr::as_vector()
spectraIndex
styler:::style_active_file()
library(devtools)
load_all()
c("tidyverse", "tidymodels", "tidypaleo", "sf", "terra", "padr", "vegan", "analogue", "patchwork", "ggfortify", "zoo", "arrow", "dtplyr", "here", "quarto", "gt", "EMMAgeo", "robCompositions", "zCompositions", "pcaPP", "torch", "luz", "viridis", "cols4all", "stars", "rbacon", "rplum", "Bchron", "oxcAAR", "nickmckay/geoChronR", "LinkedEarth/actR", "gratia", "janitor", "devtools", "duckdb", "styler", "paletteer", "FactoMineR", "factoextra", "corrr", "ggbeeswarm", "ggrepel", "ggtern", "umap", "uwot", "dbscan", "adespatial", "align", "plotly", "datapasta", "cmocean", "changepoint", "era", "imager", "palinsol", "rgugik", "writexl", "rLakeAnalyzer", "intRinsic", "BINCOR", "kears", "tictoc", "rgdal", "smoother", and "spatialEco") |>
c("tidyverse", "tidymodels", "tidypaleo", "sf", "terra", "padr", "vegan", "analogue", "patchwork", "ggfortify", "zoo", "arrow", "dtplyr", "here", "quarto", "gt", "EMMAgeo", "robCompositions", "zCompositions", "pcaPP", "torch", "luz", "viridis", "cols4all", "stars", "rbacon", "rplum", "Bchron", "oxcAAR", "nickmckay/geoChronR", "LinkedEarth/actR", "gratia", "janitor", "devtools", "duckdb", "styler", "paletteer", "FactoMineR", "factoextra", "corrr", "ggbeeswarm", "ggrepel", "ggtern", "umap", "uwot", "dbscan", "adespatial", "align", "plotly", "datapasta", "cmocean", "changepoint", "era", "imager", "palinsol", "rgugik", "writexl", "rLakeAnalyzer", "intRinsic", "BINCOR", "kears", "tictoc", "rgdal", "smoother", "spatialEco") |>
purrr::map(\(x) pak::pkg_install(x, upgrade = TRUE, dependencies = TRUE))
rlang::last_trace()
install.packages("rgdal")
install.packages("smoother")
install.packages("spatialEco")
styler:::style_active_file()
styler:::style_selection()
