#save paths for images too?
return(list(allbands = allbands,
#spectra = spectra,
wavelengths = wavelengthsOut,
normalized = normalized,
scaleY = scaleY,
stripe = stripe,
cmPerPixel = cmPerPixel,
roi = roi,
corename = corename,
pngPath = paths$overview,
normParams = normParams,
outputDir = output.dir))
#save paths for images too?
return(list(allbands = allbands,
#spectra = spectra,
wavelengths = wavelengthsOut,
normalized = normalized,
scaleY = scaleY,
#  stripe = stripe,
cmPerPixel = cmPerPixel,
roi = roi,
corename = corename,
pngPath = paths$overview,
normParams = normParams,
outputDir = output.dir))
#save paths for images too?
return(list(allbands = allbands,
#spectra = spectra,
wavelengths = wavelengthsOut,
normalized = normalized,
scaleY = scaleY,
#  stripe = stripe,
cmPerPixel = cmPerPixel,
roi = roi,
corename = corename,
pngPath = paths$overview,
# normParams = normParams,
outputDir = output.dir))
dat <- full_spectra()
#' @param cmPerPixel optionally specify the number of cm per pixel. Will determine interactively if NA. (default = NA)
#' @param spectra which spectra to normalize
#' @param roi rasterExtent object defining region of interest. NA will allow you to choose interactively (default = NA)
#' @param output.dir optionally save output raster by specifyign the path
#' @param corename optionally choose the length of the core
#'
#' @import raster crayon
#'
#' @return a normalized hyperspectral image
#' @export
full_spectra <- function(directory = NA,
length.out = NA,
wavelengths = NA,
roi = NA,#specify roi as raster extent
output.dir = NA,
corename = NA){
# spectraString <- glue::glue("wavelengths = c({paste(as.character(wavelengths),collapse = ', ')})")
#print that you need to pick it.
#get the appropriate paths
# directory <- NA
if(is.na(directory)){
cat(crayon::bold("Choose a file within the Specim core directory\n"))
Sys.sleep(1)
}
paths <- getPaths(dirPath = directory)
directory <- dirname(paths$overview)
dirString <- glue::glue("directory = '{directory}'")
#output directory handling
#  output.dir <- NA
if(is.na(output.dir)){
output.dir <- file.path(dirname(paths$overview),"products")
}
outputdirString <- glue::glue("output.dir = '{output.dir}'")
#folder name
# corename <- NA
if(is.na(corename)){
corename <-  basename(dirname(paths$overview))
}
corenameString <- glue::glue("corename = '{corename}'")
#load overview
overview <- raster::brick(paths$overview)
#ADDED
#    roi <- NA
#choose the ROI
if(!class(roi)=="Extent"){
roi <- pick_roi_shiny(overview)
}
#record roi string
roiString <- glue::glue("roi = raster::extent(matrix(c({roi@xmin},{roi@xmax},{roi@ymin},{roi@ymax}),nrow = 2,byrow = T))")
#load in the capture
filen <- raster::brick(paths$capture)
#  sample roi (WHILE IMAGE ISNT WORKING)
#roi <- raster::extent(matrix(c(xmin = 400 ,xmax =600 ,ymin =200 , ymax =500),nrow=2,byrow = TRUE))
#Create whole core images
# #for now, just using core png.
# rgbWavelengths <- c(572,539,430)
# rgbi <- getNearestWavelengths(filen = filen, spectra = rgbWavelengths)
orig.ext <- raster::extent(filen)
#save all band names for later
allbands <- getBandInfo(filen)
#find correct wavelengths
wavelengthsOut <- gsub("X","",names(filen))%>%as.numeric()
#get length, then subset
cmPerPixel <- NA
if(is.na(cmPerPixel)){
roi <- roi[[1]]
#try cropping the image with the same height, but on the right side to look at the top bottom
tr_roi <- roi
tr_roi@xmax <- raster::extent(overview)@xmax
tr_roi@xmin <- raster::extent(overview)@xmax*.75
tr_roi@ymin <- tr_roi@ymax - 1200
tr_roi@ymax <- tr_roi@ymax + 1200
tr_roi@ymin <- max(c(tr_roi@ymin,orig.ext@ymin))
tr_roi@ymax <- min(c(tr_roi@ymax,orig.ext@ymax))
tr.image <- raster::crop(overview,tr_roi)
br_roi <- tr_roi
br_roi@ymin <- roi@ymin - 1200
br_roi@ymax <- roi@ymin + 1200
br_roi@ymin <- max(c(br_roi@ymin,orig.ext@ymin))
br_roi@ymax <- min(c(br_roi@ymax,orig.ext@ymax))
br.image <- raster::crop(overview,br_roi)
cmPerPixel <- pick_length_shiny(tr.image,br.image,roi)
}
cmPerPixelString <- glue::glue("cmPerPixel = {cmPerPixel}")
#export parameters for rerunning
#  no spectra string right now, fix later
#normParams <- glue::glue("{dirString},\n{cmPerPixelString},\n{spectraString},\n{roiString},\n{outputdirString},\n{corenameString}")
#assign to global just incase it fails
#also fails
# assign("normParams",normParams,envir = .GlobalEnv)
#crop the image
if(is.finite(cmPerPixel) & cmPerPixel > 0){
scaleY <- seq(from = cmPerPixel/2,to = (dim(filen)[1]*cmPerPixel)-cmPerPixel/2,by = cmPerPixel)
}else{
#calculate length interval of each pixel (necessary for indices calculations)
scaleY <- coreLength(stripe = roi, length = length)
}
#crop_1 <- raster::crop
#test how slow the crop function is for .5 cm interval (6 times) or jst 3 cm interval
#chunk into .5 cm bits, normalizate against the white dark lines, average into a single spectra.
length.out <- 1
chunk <- 0.5
sub <- raster::extent(filen@extent@xmin,filen@extent@xmax,filen@extent@ymin,length(which(scaleY <= length.out)))
full_spectra <- raster::crop(filen,sub)
new_vals <- raster::aggregate(full_spectra,fact=c(1,(((full_spectra@extent@ymax-full_spectra@extent@ymin)/((length.out/chunk)-1)))),FUN=mean)
#load in the white and dark refs
whiteRef <- raster::brick(paths$whiteref)
darkRef <- raster::brick(paths$darkref)
white.ref <- processReference(whiteRef,stripe = full_spectra,spectra = names(whiteRef))
dark.ref <- processReference(darkRef,stripe = full_spectra,spectra = names(whiteRef))
#now normalize
normalized <- whiteDarkNormalize(stripe = full_spectra, white.ref = white.ref, dark.ref = dark.ref)
if(!dir.exists(file.path(output.dir))){
dir.create(file.path(output.dir))
}
if(!dir.exists(file.path(output.dir,corename))){
dir.create(file.path(output.dir,corename))
}
#save normalized core image
normalizedImage <- normalizeCoreImage(paths$overview)
imager::save.image(normalizedImage,file = file.path(output.dir,"normalizedCoreImage.png"))
raster::writeRaster(normalized,file.path(output.dir,"normalized.tif"),overwrite = TRUE)
#save normalized data for future reference
save(normalized,file = file.path(output.dir,"normalized.RData"))
#save paths for images too?
return(list(allbands = allbands,
#spectra = spectra,
wavelengths = wavelengthsOut,
normalized = normalized,
scaleY = scaleY,
#  stripe = stripe,
cmPerPixel = cmPerPixel,
roi = roi,
corename = corename,
pngPath = paths$overview,
# normParams = normParams,
outputDir = output.dir))
}
dat <- full_spectra()
#folder name
# corename <- NA
if(is.na(corename)){
corename <-  basename(dirname(paths$overview))
}
corenameString <- glue::glue("corename = '{corename}'")
#load overview
overview <- raster::brick(paths$overview)
#ADDED
#    roi <- NA
#choose the ROI
if(!class(roi)=="Extent"){
roi <- pick_roi_shiny(overview)
}
roiString <- glue::glue("roi = raster::extent(matrix(c({roi@xmin},{roi@xmax},{roi@ymin},{roi@ymax}),nrow = 2,byrow = T))")
roi
roiString <- glue::glue("roi = raster::extent(matrix(c({roi@xmin},{roi@xmax},{roi@ymin},{roi@ymax}),nrow = 2,byrow = T))")
#record roi string
roi <- roi[[1]]
roiString <- glue::glue("roi = raster::extent(matrix(c({roi@xmin},{roi@xmax},{roi@ymin},{roi@ymax}),nrow = 2,byrow = T))")
source('~/Documents/GitHub/specimR/R/full_spectra.R')
dat <- full_spectra()
dat
source('~/Documents/GitHub/specimR/R/full_spectra.R')
new_vals
plot(new_vals)
dim(new_vals)
dim(full_spectra())
dim(full_spectra
#load in the white and dark refs
whiteRef <- raster::brick(paths$whiteref)
darkRef <- raster::brick(paths$darkref)
white.ref <- processReference(whiteRef,stripe = full_spectra,spectra = names(whiteRef))
dark.ref <- processReference(darkRef,stripe = full_spectra,spectra = names(whiteRef))
#now normalize
normalized <- whiteDarkNormalize(stripe = full_spectra, white.ref = white.ref, dark.ref = dark.ref)
if(!dir.exists(file.path(output.dir))){
dir.create(file.path(output.dir))
}
if(!dir.exists(file.path(output.dir,corename))){
dir.create(file.path(output.dir,corename))
}
#save normalized core image
normalizedImage <- normalizeCoreImage(paths$overview)
imager::save.image(normalizedImage,file = file.path(output.dir,"normalizedCoreImage.png"))
raster::writeRaster(normalized,file.path(output.dir,"normalized.tif"),overwrite = TRUE)
dim(full_spectra)
full_spectra <- raster::crop(filen,sub)
chunk <- 0.25
dim(full_spectra)
new_vals <- raster::aggregate(full_spectra,fact=c(1,(((full_spectra@extent@ymax-full_spectra@extent@ymin)/((length.out/chunk)-1)))),FUN=mean)
new_vals
plot(new_vals[[1]])
plot(new_vals[1])
plot(new_vals[1])
plot(new_vals[1,])
plot(new_vals[,])
source('~/Documents/GitHub/specimR/R/full_spectra.R')
darkRef
dim(new_vals)
dim(whiteRef)
source('~/Documents/GitHub/specimR/R/full_spectra.R')
source('~/Documents/GitHub/specimR/R/roi.R')
source('~/Documents/GitHub/specimR/R/shinyLength.R')
source('~/Documents/GitHub/specimR/R/normalize.R')
source('~/Documents/GitHub/specimR/R/coreImage.R')
library(shiny)
library(raster)
library(specimR)
library(magrittr)
library(dplyr)
library(readr)
library(tidyr)
library(tibble)
library(tictoc)
f <- full_spectra()
source('~/Documents/GitHub/specimR/R/SpectralCalculationsNick.R')
f <- full_spectra()
directory <- NA
if(is.na(directory)){
cat(crayon::bold("Choose a file within the Specim core directory\n"))
Sys.sleep(1)
}
paths <- getPaths(dirPath = directory)
directory <- dirname(paths$overview)
dirString <- glue::glue("directory = '{directory}'")
dirString
directory <- dirname(paths$overview)
directory <- NA
if(is.na(directory)){
cat(crayon::bold("Choose a file within the Specim core directory\n"))
Sys.sleep(1)
}
paths <- getPaths(dirPath = directory)
directory <- dirname(paths$overview)
dirString <- glue::glue("directory = '{directory}'")
#output directory handling
#  output.dir <- NA
if(is.na(output.dir)){
output.dir <- file.path(dirname(paths$overview),"products")
}
output.dir <- NA
if(is.na(output.dir)){
output.dir <- file.path(dirname(paths$overview),"products")
}
outputdirString <- glue::glue("output.dir = '{output.dir}'")
corename <- NA
if(is.na(corename)){
corename <-  basename(dirname(paths$overview))
}
corenameString <- glue::glue("corename = '{corename}'")
#load overview
overview <- raster::brick(paths$overview)
roi <- NA
#choose the ROI
if(!class(roi)=="Extent"){
roiList <- pick_roi_shiny(overview,nrow(overview)/5)
}
#record roi string
roi <- roiList[[1]]
roiString <- glue::glue("roi = raster::extent(matrix(c({roi@xmin},{roi@xmax},{roi@ymin},{roi@ymax}),nrow = 2,byrow = T))")
filen <- raster::brick(paths$capture)
orig.ext <- raster::extent(filen)
#save all band names for later
allbands <- getBandInfo(filen)
#find correct wavelengths
wavelengthsOut <- gsub("X","",names(filen))%>%as.numeric()
#get length, then subset
#cmPerPixel <- NA
if(is.na(cmPerPixel)){
# roi <- roi[[1]]
#try cropping the image with the same height, but on the right side to look at the top bottom
tr_roi <- roi
tr_roi@xmax <- raster::extent(overview)@xmax
tr_roi@xmin <- raster::extent(overview)@xmax*.75
tr_roi@ymin <- tr_roi@ymax - 1200
tr_roi@ymax <- tr_roi@ymax + 1200
tr_roi@ymin <- max(c(tr_roi@ymin,orig.ext@ymin))
tr_roi@ymax <- min(c(tr_roi@ymax,orig.ext@ymax))
tr.image <- raster::crop(overview,tr_roi)
br_roi <- tr_roi
br_roi@ymin <- roi@ymin - 1200
br_roi@ymax <- roi@ymin + 1200
br_roi@ymin <- max(c(br_roi@ymin,orig.ext@ymin))
br_roi@ymax <- min(c(br_roi@ymax,orig.ext@ymax))
br.image <- raster::crop(overview,br_roi)
cmPerPixel <- pick_length_shiny(tr.image,br.image,roi)
}
cmPerPixel <- NA
if(is.na(cmPerPixel)){
# roi <- roi[[1]]
#try cropping the image with the same height, but on the right side to look at the top bottom
tr_roi <- roi
tr_roi@xmax <- raster::extent(overview)@xmax
tr_roi@xmin <- raster::extent(overview)@xmax*.75
tr_roi@ymin <- tr_roi@ymax - 1200
tr_roi@ymax <- tr_roi@ymax + 1200
tr_roi@ymin <- max(c(tr_roi@ymin,orig.ext@ymin))
tr_roi@ymax <- min(c(tr_roi@ymax,orig.ext@ymax))
tr.image <- raster::crop(overview,tr_roi)
br_roi <- tr_roi
br_roi@ymin <- roi@ymin - 1200
br_roi@ymax <- roi@ymin + 1200
br_roi@ymin <- max(c(br_roi@ymin,orig.ext@ymin))
br_roi@ymax <- min(c(br_roi@ymax,orig.ext@ymax))
br.image <- raster::crop(overview,br_roi)
cmPerPixel <- pick_length_shiny(tr.image,br.image,roi)
}
cmPerPixelString <- glue::glue("cmPerPixel = {cmPerPixel}")
if(is.finite(cmPerPixel) & cmPerPixel > 0){
scaleY <- seq(from = cmPerPixel/2,to = (dim(filen)[1]*cmPerPixel)-cmPerPixel/2,by = cmPerPixel)
}else{
#calculate length interval of each pixel (necessary for indices calculations)
scaleY <- coreLength(stripe = roi, length = length)
}
chunk.top <- 0
chunk.bot <- 1
length.out <- chunk.bot - chunk.top
chunk.step <- 0.25
pixel.top <- ceiling(.01+chunk.top/cmPerPixel)
pixel.bot <- floor(chunk.bot/cmPerPixel)
sub <- raster::extent(roi@xmin,roi@xmax,pixel.top,pixel.bot)
full.spectra <- raster::crop(filen,sub)
new.vals <- raster::aggregate(full.spectra,
fact=c(1,ceiling((full.spectra@extent@ymax-full.spectra@extent@ymin)/((length.out/chunk.step)))),
FUN=mean)
#load in the white and dark refs
whiteRef <- raster::brick(paths$whiteref)
wRef <- raster::aggregate(whiteRef,
fact=c(1,ceiling((whiteRef@extent@ymax-whiteRef@extent@ymin)/((length.out/chunk.step)))),
FUN=mean)
darkRef <- raster::brick(paths$darkref)
dRef <- raster::aggregate(darkRef,
fact=c(1,ceiling((darkRef@extent@ymax-darkRef@extent@ymin)/((length.out/chunk.step)))),
FUN=mean)
#white.ref <- processReference(whiteRef,stripe = sub,spectra = names(whiteRef))
#white.ref <- processReference(whiteRef,stripe = new.vals,spectra = names(whiteRef))
white.ref <- processReference(wRef,stripe = new.vals,spectra = names(wRef))
w.ref <- raster::aggregate(white.ref,
fact=c(1,ceiling((full.spectra@extent@ymax-full.spectra@extent@ymin)/((length.out/chunk.step)))),
FUN=mean)
#dark.ref <- processReference(darkRef,stripe = sub,spectra = names(whiteRef))
#dark.ref <- processReference(darkRef,stripe = new.vals,spectra = names(whiteRef))
dark.ref <- processReference(dRef,stripe = new.vals,spectra = names(dRef))
d.ref <- raster::aggregate(dark.ref,
fact=c(1,ceiling((full.spectra@extent@ymax-full.spectra@extent@ymin)/((length.out/chunk.step)))),
FUN=mean)
#now normalize
normalized <- whiteDarkNormalize(stripe = new.vals, white.ref = w.ref, dark.ref = d.ref)
if(!dir.exists(file.path(output.dir))){
dir.create(file.path(output.dir))
}
if(!dir.exists(file.path(output.dir,corename))){
dir.create(file.path(output.dir,corename))
}
normData <- calculateMeanRows(normalized = normalized)
normalized
normalized$normalized
averageRow <- function(rn,r){
a <- apply(raster::getValues(r,rn,1),2,mean)
}
averageRow
averageRow <- function(rn,r){
a <- apply(raster::getValues(r,rn,1),2,mean)
}
data <- purrr::map_df(seq_len(nrow(normalized$normalized)),averageRow,normalized$normalized) %>%
as.matrix
#  data <- purrr::map_df(seq_len(nrow(normalized$normalized)),averageRow,normalized$normalized) %>%
#    as.matrix
data <- purrr::map_df(seq_len(nrow(normalized)),averageRow,normalized) %>%
as.matrix
colnames(data) <- names(normalized$spectra)
colnames(data) <- names(normalized)
colnames(data)
normData <- MeanRowSpectra(normalized = normalized)
source('~/Documents/GitHub/specimR/R/full_spectra.R')
source('~/Documents/GitHub/specimR/R/SpectralCalculationsNick.R')
normData <- MeanRowSpectra(normalized = normalized)
#save normalized core image
normalizedImage <- normalizeCoreImage(paths$overview)
imager::save.image(normalizedImage,file = file.path(output.dir,"normalizedCoreImage.png"))
raster::writeRaster(normalized,file.path(output.dir,"normalized.tif"),overwrite = TRUE)
#save normalized data for future reference
save(normalized,file = file.path(output.dir,"normalized.RData"))
#save paths for images too?
return(list(allbands = allbands,
#spectra = spectra,
wavelengths = wavelengthsOut,
normalized = normalized,
scaleY = scaleY,
#  stripe = stripe,
cmPerPixel = cmPerPixel,
roi = roi,
corename = corename,
pngPath = paths$overview,
# normParams = normParams,
outputDir = output.dir))
source('~/Documents/GitHub/specimR/R/roi.R')
source('~/Documents/GitHub/specimR/R/shinyLength.R')
source('~/Documents/GitHub/specimR/R/normalize.R')
source('~/Documents/GitHub/specimR/R/coreImage.R')
source('~/Documents/GitHub/specimR/R/SpectralCalculationsNick.R')
library(shiny)
library(raster)
library(specimR)
library(magrittr)
library(dplyr)
library(readr)
library(tidyr)
library(tibble)
library(tictoc)
f <- full_spectra()
f
f <- full_spectra()
plot(f)
plot(f$normalized)
f$normalized
f$normalized[1]
plot(f$normalized[1:100]
plot(f$normalized[1:100])
plot(f$normalized[1:100])
plot(f$normalized[1:100,,])
plot(f$normalized[,1:100,])
plot(f$normalized[,,1:100])
f$normalized
f$normalized[1]
f$normalized[571]
f$normalized[573]
f$normalized[5730]
f$normalized[574]
f$normalized
f$normalized[800]
f$normalized[2200]
f$normalized[2400]
f
f$normalized
f$normalized[2289]
f$normalized[2288]
f$normalized
plot(f$normalized[1],f$normalized[2])
source('~/Documents/GitHub/specimR/R/roi.R')
source('~/Documents/GitHub/specimR/R/shinyLength.R')
source('~/Documents/GitHub/specimR/R/normalize.R')
source('~/Documents/GitHub/specimR/R/coreImage.R')
source('~/Documents/GitHub/specimR/R/SpectralCalculationsNick.R')
library(shiny)
library(raster)
library(specimR)
library(magrittr)
library(dplyr)
library(readr)
library(tidyr)
library(tibble)
library(tictoc)
f <- full_spectra()
source('~/Documents/GitHub/specimR/R/full_spectra.R')
f <- full_spectra()
readxl::read_excel("/Users/ethanyackulic/Documents/GitHub/Lakes380-surface-spectral-calibration/data/Surface_Sediment_PigmentAndHSI.xlsx")
NZ <- readxl::read_excel("/Users/ethanyackulic/Documents/GitHub/Lakes380-surface-spectral-calibration/data/Surface_Sediment_PigmentAndHSI.xlsx")
dim(NZ)
?readxl::read_excel
NZ1 <- readxl::read_excel("/Users/ethanyackulic/Documents/GitHub/Lakes380-surface-spectral-calibration/data/Surface_Sediment_PigmentAndHSI.xlsx",sheet = 1)
NZ2 <- readxl::read_excel("/Users/ethanyackulic/Documents/GitHub/Lakes380-surface-spectral-calibration/data/Surface_Sediment_PigmentAndHSI.xlsx",sheet = 2)
NZ3 <- readxl::read_excel("/Users/ethanyackulic/Documents/GitHub/Lakes380-surface-spectral-calibration/data/Surface_Sediment_PigmentAndHSI.xlsx",sheet = 3)
NZ4 <- readxl::read_excel("/Users/ethanyackulic/Documents/GitHub/Lakes380-surface-spectral-calibration/data/Surface_Sediment_PigmentAndHSI.xlsx",sheet = 4)
dim(NZ1)
dim(NZ3)
dim(NZ4)
pigments <- readxl::read_excel("/Users/ethanyackulic/Documents/GitHub/Lakes380-surface-spectral-calibration/data/Surface_Sediment_PigmentAndHSI.xlsx",sheet = 1)
surface_seds <- readxl::read_excel("/Users/ethanyackulic/Documents/GitHub/Lakes380-surface-spectral-calibration/data/Surface_Sediment_PigmentAndHSI.xlsx",sheet = 2)
bulk <- readxl::read_excel("/Users/ethanyackulic/Documents/GitHub/Lakes380-surface-spectral-calibration/data/Surface_Sediment_PigmentAndHSI.xlsx",sheet = 3)
JP <- readxl::read_excel("/Users/ethanyackulic/Documents/GitHub/Lakes380-surface-spectral-calibration/data/Surface_Sediment_PigmentAndHSI.xlsx",sheet = 4)
JP
