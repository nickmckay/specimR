#read in png
image <- magick::read_image("~/Documents/GitHub/specimR/test/Lakes380_FORSY_LC1U_2B_test_2020_06_05_04-05-39.png")
#read in png
plot("~/Documents/GitHub/specimR/test/Lakes380_FORSY_LC1U_2B_test_2020_06_05_04-05-39.png")
#read in png
imager::plot("~/Documents/GitHub/specimR/test/Lakes380_FORSY_LC1U_2B_test_2020_06_05_04-05-39.png")
#read in png
imager::load.image("~/Documents/GitHub/specimR/test/Lakes380_FORSY_LC1U_2B_test_2020_06_05_04-05-39.png")
#read in png
img <- imager::load.image("~/Documents/GitHub/specimR/test/Lakes380_FORSY_LC1U_2B_test_2020-06-05_04-05-39.png")
plot(img)
log(img)+3*sqrt(img)
i2 < log(img)+3*sqrt(img)
i2 <- log(img)+3*sqrt(img)
plot(i2)
img
i2 <- log(img)+3
plot(i2)
plot(img*2,rescale=FALSE)
plot(img*1.5,rescale=FALSE)
plot(img*1.4,rescale=FALSE)
plot(img*1.3,rescale=FALSE)
plot(img*1.1,rescale=FALSE)
plot(img,rescale=FALSE)
plot(img,rescale=TRUE)
plot(img)%>% hist()
img%>% hist()
#workflow for image acquisition
library(dplyr)
img%>% hist()
#read in png
im <- imager::load.image("~/Documents/GitHub/specimR/test/Lakes380_FORSY_LC1U_2B_test_2020-06-05_04-05-39.png")
hist.eq <- function(im) as.cimg(ecdf(im)(im),dim=dim(im))
hist.eq
hist.eq(im)
library(cimg)
hist.eq <- function(im) imager::as.cimg(ecdf(im)(im),dim=dim(im))
hist.eq(im)
im2 <- hist.eq(im)
plot(im2)
plot(im)
hist.eq <- function(im) imager::as.cimg(ecdf(im)(im),dim=dim(im))
im2 <- hist.eq(im)
plot(im2)
cn <- imsplit(im,"c")
cn <- imager::imsplit(im,"c")
cn.eq <- map_il(cn,hist.eq) #run hist.eq on each
cn.eq <- imager::map_il(cn,hist.eq) #run hist.eq on each
imager::imappend(cn.eq,"c") %>% plot(main="All channels equalised") #recombine and plot
plot(im2)
im2 <- imager::imappend(cn.eq,"c") %>% plot(main="All channels equalised") #recombine and plot
plot(im2)
im2 %>%hist()
im%>%hist()
im%>%hist(main="Distribution of color intensity values")
im2 %>%hist(main="Distribution of color intensity values with all channels equalised")
plot(im2)
cn
im2
im2
(covar <-(((x1[1]-m1)*(x2[1]-m2))+((x1[2]-m1)*(x2[2]-m2))+((x1[3]-m1)*(x2[3]-m2))+((x1[4]-m1)*(x2[4]-m2))+((x1[5]-m1)*(x2[5]-m2))+((x1[6]-m1)*(x2[6]-m2))+((x1[7]-m1)*(x2[7]-m2)))/7)
x1 <- c(3,4,2,6,8,2,5)
x2 <- c(5,5.5,4,7,10,5,7.5)
#Sample Means
(m1 <- mean(x1))
(m2 <- mean(x2))
#Sample Variance
(var1 <- ((x1[1]-m1)^2 + (x1[2]-m1)^2 +(x1[3]-m1)^2 +(x1[4]-m1)^2 +(x1[5]-m1)^2 +(x1[6]-m1)^2 +(x1[7]-m1)^2)/7)
(var2 <- ((x2[1]-m2)^2 + (x2[2]-m2)^2 +(x2[3]-m2)^2 +(x2[4]-m2)^2 +(x2[5]-m2)^2 +(x2[6]-m2)^2 +(x2[7]-m2)^2)/7)
#this question depends on whether N is denoting a population or sample. If we assume that the vector is measurements of population, then N=7. However, if it is indeed a sample as qualified in the question, N=7-1, or 6. This changes the variance values for both sets.
(var1a <- ((x1[1]-m1)^2 + (x1[2]-m1)^2 +(x1[3]-m1)^2 +(x1[4]-m1)^2 +(x1[5]-m1)^2 +(x1[6]-m1)^2 +(x1[7]-m1)^2)/6)
(var2a <- ((x2[1]-m2)^2 + (x2[2]-m2)^2 +(x2[3]-m2)^2 +(x2[4]-m2)^2 +(x2[5]-m2)^2 +(x2[6]-m2)^2 +(x2[7]-m2)^2)/6)
#checking my values against Rs built-in variance calculator
var(x)
var(x2)
#checking my values against Rs built-in variance calculator
var(x1)
var(x2)
(covar <-(((x1[1]-m1)*(x2[1]-m2))+((x1[2]-m1)*(x2[2]-m2))+((x1[3]-m1)*(x2[3]-m2))+((x1[4]-m1)*(x2[4]-m2))+((x1[5]-m1)*(x2[5]-m2))+((x1[6]-m1)*(x2[6]-m2))+((x1[7]-m1)*(x2[7]-m2)))/7)
(covar1 <- (((x1[1]-m1)*(x2[1]-m2))+((x1[2]-m1)*(x2[2]-m2))+((x1[3]-m1)*(x2[3]-m2))+((x1[4]-m1)*(x2[4]-m2))+((x1[5]-m1)*(x2[5]-m2))+((x1[6]-m1)*(x2[6]-m2))+((x1[7]-m1)*(x2[7]-m2)))/6)
cov(x1,x2)
mean(x1)
mean(x2)
mean(x3)
x1 <- c(9,2,6,5,8)
x2 <- c(12,8,6,4,10)
x3 <- c(3,4,0,2,1)
mean(x1)
mean(x2)
mean(x3)
var(x1)
var(x2)
var(x3)
cov(x1,x2)
cov(x1,x3)
cov(x2,x3)
x1
n = length(x1)
var(x1)* (n-1)/n
var(x2)* (n-1)/n
var(x3)* (n-1)/n
cov(x1,x2)
cov(x1,x2)* (n-1)/n
cov(x1,x3)* (n-1)/n
cov(x2,x3)* (n-1)/n
cor(x1,x2)
cor(x1,x3)
cor(x2,x3)
getwd()
library(tinytex)
update.packages(ask = FALSE, checkBuilt = TRUE)
tinytex::tlmgr_update()
tinytex::tlmgr_update()
setValues
??setValues
sub
scaleY
#' @param cmPerPixel optionally specify the number of cm per pixel. Will determine interactively if NA. (default = NA)
#' @param spectra which spectra to normalize
#' @param roi rasterExtent object defining region of interest. NA will allow you to choose interactively (default = NA)
#' @param output.dir optionally save output raster by specifyign the path
#' @param corename optionally choose the length of the core
#'
#' @import raster crayon
#'
#' @return a normalized hyperspectral image
#' @export
full_spectra <- function(directory = NA,
length.out = NA,
roi = NA,#specify roi as raster extent
output.dir = NA,
corename = NA){
spectraString <- glue::glue("wavelengths = c({paste(as.character(wavelengths),collapse = ', ')})")
#print that you need to pick it.
#get the appropriate paths
directory <- NA
if(is.na(directory)){
cat(crayon::bold("Choose a file within the Specim core directory\n"))
Sys.sleep(1)
}
paths <- getPaths(dirPath = directory)
directory <- dirname(paths$overview)
dirString <- glue::glue("directory = '{directory}'")
#output directory handling
if(is.na(output.dir)){
output.dir <- file.path(dirname(paths$overview),"products")
}
outputdirString <- glue::glue("output.dir = '{output.dir}'")
#folder name
if(is.na(corename)){
corename <-  basename(dirname(paths$overview))
}
corenameString <- glue::glue("corename = '{corename}'")
#load overview
overview <- raster::brick(paths$overview)
#ADDED
roi <- NA
source('~/Documents/GitHub/specimR/R/roi.R')
#choose the ROI
if(!class(roi)=="Extent"){
roi <- pick_roi_shiny(overview)
}
#record roi string
roiString <- glue::glue("roi = raster::extent(matrix(c({roi@xmin},{roi@xmax},{roi@ymin},{roi@ymax}),nrow = 2,byrow = T))")
#load in the capture
filen <- raster::brick(paths$capture)
#Create whole core images
# #for now, just using core png.
# rgbWavelengths <- c(572,539,430)
# rgbi <- getNearestWavelengths(filen = filen, spectra = rgbWavelengths)
orig.ext <- raster::extent(filen)
#save all band names for later
allbands <- getBandInfo(filen)
#find correct wavelengths
wavelengthsOut <- gsub("X","",names(filen))%>%as.numeric()
#get length, then subset
if(is.na(cmPerPixel)){
#try cropping the image with the same height, but on the right side to look at the top bottom
tr_roi <- roi
tr_roi@xmax <- raster::extent(overview)@xmax
tr_roi@xmin <- raster::extent(overview)@xmax*.75
tr_roi@ymin <- tr_roi@ymax - 1200
tr_roi@ymax <- tr_roi@ymax + 1200
tr_roi@ymin <- max(c(tr_roi@ymin,orig.ext@ymin))
tr_roi@ymax <- min(c(tr_roi@ymax,orig.ext@ymax))
tr.image <- raster::crop(overview,tr_roi)
br_roi <- tr_roi
br_roi@ymin <- roi@ymin - 1200
br_roi@ymax <- roi@ymin + 1200
br_roi@ymin <- max(c(br_roi@ymin,orig.ext@ymin))
br_roi@ymax <- min(c(br_roi@ymax,orig.ext@ymax))
br.image <- raster::crop(overview,br_roi)
cmPerPixel <- pick_length_shiny(tr.image,br.image,roi)
}
cmPerPixelString <- glue::glue("cmPerPixel = {cmPerPixel}")
#export parameters for rerunning
#  no spectra string right now, fix later
#normParams <- glue::glue("{dirString},\n{cmPerPixelString},\n{spectraString},\n{roiString},\n{outputdirString},\n{corenameString}")
#assign to global just incase it fails
#also fails
# assign("normParams",normParams,envir = .GlobalEnv)
#crop the image
if(is.finite(cmPerPixel) & cmPerPixel > 0){
scaleY <- seq(from = cmPerPixel/2,to = (dim(filen)[1]*cmPerPixel)-cmPerPixel/2,by = cmPerPixel)
}else{
#calculate length interval of each pixel (necessary for indices calculations)
scaleY <- coreLength(stripe = stripe, length = length)
}
length(scaleY)
#crop_1 <- raster::crop
#test how slow the crop function is for .5 cm interval (6 times) or jst 3 cm interval
#chunk into .5 cm bits, normalizate against the white dark lines, average into a single spectra.
length.out <- 5
sub <- extent(filen@extent@xmin,filen@extent@xmax,filen@extent@ymin,length(which(scaleY <= length.out)))
full_spectra <- raster::crop(filen,sub)
dim(raster::crop(filen[filen@ncols],sub))
stripe
extent(filen)
#load in the white and dark refs
whiteRef <- raster::brick(paths$whiteref)
darkRef <- raster::brick(paths$darkref)
white.ref <- processReference(whiteRef,stripe = stripe,spectra = spectra)
dark.ref <- processReference(darkRef,stripe = stripe,spectra = spectra)
#now normalize
normalized <- whiteDarkNormalize(stripe = stripe, white.ref = white.ref, dark.ref = dark.ref)
if(!dir.exists(file.path(output.dir))){
dir.create(file.path(output.dir))
}
if(!dir.exists(file.path(output.dir,corename))){
dir.create(file.path(output.dir,corename))
}
#save normalized core image
normalizedImage <- normalizeCoreImage(paths$overview)
imager::save.image(normalizedImage,file = file.path(output.dir,"normalizedCoreImage.png"))
raster::writeRaster(normalized,file.path(output.dir,"normalized.tif"),overwrite = TRUE)
#save normalized data for future reference
save(normalized,file = file.path(output.dir,"normalized.RData"))
#save paths for images too?
return(list(allbands = allbands,
spectra = spectra,
wavelengths = wavelengthsOut,
normalized = normalized,
scaleY = scaleY,
stripe = stripe,
cmPerPixel = cmPerPixel,
roi = roi,
corename = corename,
pngPath = paths$overview,
normParams = normParams,
outputDir = output.dir))
}
directory <- NA
if(is.na(directory)){
cat(crayon::bold("Choose a file within the Specim core directory\n"))
Sys.sleep(1)
}
paths <- getPaths(dirPath = directory)
source('~/Documents/GitHub/specimR/R/roi.R')
source('~/Documents/GitHub/specimR/R/shinyLength.R')
source('~/Documents/GitHub/specimR/R/normalize.R')
directory <- NA
if(is.na(directory)){
cat(crayon::bold("Choose a file within the Specim core directory\n"))
Sys.sleep(1)
}
paths <- getPaths(dirPath = directory)
directory <- dirname(paths$overview)
dirString <- glue::glue("directory = '{directory}'")
#output directory handling
if(is.na(output.dir)){
output.dir <- file.path(dirname(paths$overview),"products")
}
outputdirString <- glue::glue("output.dir = '{output.dir}'")
#load overview
overview <- raster::brick(paths$overview)
#ADDED
roi <- NA
source('~/Documents/GitHub/specimR/R/roi.R')
#choose the ROI
if(!class(roi)=="Extent"){
roi <- pick_roi_shiny(overview)
}
#record roi string
roiString <- glue::glue("roi = raster::extent(matrix(c({roi@xmin},{roi@xmax},{roi@ymin},{roi@ymax}),nrow = 2,byrow = T))")
#load in the capture
filen <- raster::brick(paths$capture)
orig.ext <- raster::extent(filen)
#save all band names for later
allbands <- getBandInfo(filen)
library(dplyr)
#save all band names for later
allbands <- getBandInfo(filen)
#find correct wavelengths
wavelengthsOut <- gsub("X","",names(filen))%>%as.numeric()
wavelengthsOut
if(is.na(cmPerPixel)){
#try cropping the image with the same height, but on the right side to look at the top bottom
tr_roi <- roi
tr_roi@xmax <- raster::extent(overview)@xmax
tr_roi@xmin <- raster::extent(overview)@xmax*.75
tr_roi@ymin <- tr_roi@ymax - 1200
tr_roi@ymax <- tr_roi@ymax + 1200
tr_roi@ymin <- max(c(tr_roi@ymin,orig.ext@ymin))
tr_roi@ymax <- min(c(tr_roi@ymax,orig.ext@ymax))
tr.image <- raster::crop(overview,tr_roi)
br_roi <- tr_roi
br_roi@ymin <- roi@ymin - 1200
br_roi@ymax <- roi@ymin + 1200
br_roi@ymin <- max(c(br_roi@ymin,orig.ext@ymin))
br_roi@ymax <- min(c(br_roi@ymax,orig.ext@ymax))
br.image <- raster::crop(overview,br_roi)
cmPerPixel <- pick_length_shiny(tr.image,br.image,roi)
}
#get length, then subset
cmPerPixel <- NA
if(is.na(cmPerPixel)){
#try cropping the image with the same height, but on the right side to look at the top bottom
tr_roi <- roi
tr_roi@xmax <- raster::extent(overview)@xmax
tr_roi@xmin <- raster::extent(overview)@xmax*.75
tr_roi@ymin <- tr_roi@ymax - 1200
tr_roi@ymax <- tr_roi@ymax + 1200
tr_roi@ymin <- max(c(tr_roi@ymin,orig.ext@ymin))
tr_roi@ymax <- min(c(tr_roi@ymax,orig.ext@ymax))
tr.image <- raster::crop(overview,tr_roi)
br_roi <- tr_roi
br_roi@ymin <- roi@ymin - 1200
br_roi@ymax <- roi@ymin + 1200
br_roi@ymin <- max(c(br_roi@ymin,orig.ext@ymin))
br_roi@ymax <- min(c(br_roi@ymax,orig.ext@ymax))
br.image <- raster::crop(overview,br_roi)
cmPerPixel <- pick_length_shiny(tr.image,br.image,roi)
}
cmPerPixelString <- glue::glue("cmPerPixel = {cmPerPixel}")
if(is.finite(cmPerPixel) & cmPerPixel > 0){
scaleY <- seq(from = cmPerPixel/2,to = (dim(filen)[1]*cmPerPixel)-cmPerPixel/2,by = cmPerPixel)
}else{
#calculate length interval of each pixel (necessary for indices calculations)
scaleY <- coreLength(stripe = stripe, length = length)
}
length(scaleY)
scaleY
cmPerPixel
#get length, then subset
cmPerPixel <- NA
if(is.na(cmPerPixel)){
#try cropping the image with the same height, but on the right side to look at the top bottom
tr_roi <- roi
tr_roi@xmax <- raster::extent(overview)@xmax
tr_roi@xmin <- raster::extent(overview)@xmax*.75
tr_roi@ymin <- tr_roi@ymax - 1200
tr_roi@ymax <- tr_roi@ymax + 1200
tr_roi@ymin <- max(c(tr_roi@ymin,orig.ext@ymin))
tr_roi@ymax <- min(c(tr_roi@ymax,orig.ext@ymax))
tr.image <- raster::crop(overview,tr_roi)
br_roi <- tr_roi
br_roi@ymin <- roi@ymin - 1200
br_roi@ymax <- roi@ymin + 1200
br_roi@ymin <- max(c(br_roi@ymin,orig.ext@ymin))
br_roi@ymax <- min(c(br_roi@ymax,orig.ext@ymax))
br.image <- raster::crop(overview,br_roi)
cmPerPixel <- pick_length_shiny(tr.image,br.image,roi)
}
roi
#ADDED
roi <- NA
source('~/Documents/GitHub/specimR/R/roi.R')
#choose the ROI
if(!class(roi)=="Extent"){
roi <- pick_roi_shiny(overview)
}
#choose the ROI
if(!class(roi)=="Extent"){
roi <- pick_roi_shiny(overview)
}
directory = NA,
length.out = NA,
roi = NA,#specify roi as raster extent
output.dir = NA,
corename = NA
directory = NA
length.out = NA
roi = NA
output.dir = NA
spectraString <- glue::glue("wavelengths = c({paste(as.character(wavelengths),collapse = ', ')})")
directory <- NA
if(is.na(directory)){
cat(crayon::bold("Choose a file within the Specim core directory\n"))
Sys.sleep(1)
}
paths <- getPaths(dirPath = directory)
#load in the capture
filen <- raster::brick(paths$capture)
orig.ext <- raster::extent(filen)
#save all band names for later
allbands <- getBandInfo(filen)
#find correct wavelengths
wavelengthsOut <- gsub("X","",names(filen))%>%as.numeric()
#get length, then subset
cmPerPixel <- NA
if(is.na(cmPerPixel)){
#try cropping the image with the same height, but on the right side to look at the top bottom
tr_roi <- roi
tr_roi@xmax <- raster::extent(overview)@xmax
tr_roi@xmin <- raster::extent(overview)@xmax*.75
tr_roi@ymin <- tr_roi@ymax - 1200
tr_roi@ymax <- tr_roi@ymax + 1200
tr_roi@ymin <- max(c(tr_roi@ymin,orig.ext@ymin))
tr_roi@ymax <- min(c(tr_roi@ymax,orig.ext@ymax))
tr.image <- raster::crop(overview,tr_roi)
br_roi <- tr_roi
br_roi@ymin <- roi@ymin - 1200
br_roi@ymax <- roi@ymin + 1200
br_roi@ymin <- max(c(br_roi@ymin,orig.ext@ymin))
br_roi@ymax <- min(c(br_roi@ymax,orig.ext@ymax))
br.image <- raster::crop(overview,br_roi)
cmPerPixel <- pick_length_shiny(tr.image,br.image,roi)
}
cmPerPixelString <- glue::glue("cmPerPixel = {cmPerPixel}")
cmPerPixel
pick_length_shiny(tr.image,br.image,roi)
#try cropping the image with the same height, but on the right side to look at the top bottom
tr_roi <- roi
tr_roi@xmax <- raster::extent(overview)@xmax
pick_roi_shiny(overview)
#load overview
overview <- raster::brick(paths$overview)
overview
pick_roi_shiny(overview)
roi <- pick_roi_shiny(overview)
pick_roi_shiny <- function(image){
#assign image into Global (hack for now)
assign("image",image,envir = specimEnv)
ui <- shiny::fluidPage(
# Some custom CSS for a smaller font for preformatted text
tags$head(
tags$style(HTML("
pre, table.table {
font-size: smaller;
}
"))
),
column(width = 12, class = "well",
h2("Region of interest (ROI) selector"),
shiny::fluidRow(
column(width = 4,
plotOutput("plot2", height = 500,
brush = brushOpts(
id = "plot2_brush",
resetOnNew = FALSE
)
)
),
column(width = 8,
plotOutput("plot3",
height = 500,
click = "image_click",
dblclick = dblclickOpts(
id = "image_dblclick"
)
)
)
),
shiny::fluidRow(
column(width = 3,
numericInput("x1",
h4("Click x"),
value = 0),
numericInput("y1",
h4("Click y"),
value = 0)
),
column(width = 3,
numericInput("x2",
h4("Dbl-Click x"),
value = 0),
numericInput("y2",
h4("Dbl-Click y"),
value = 0)
),
column(3,
numericInput("width",
h4("Specify width"),
value = 200),
actionButton("applyWidth", "Apply width"),
actionButton("center", "Center ROI"),
)
)
),
actionButton("record", "Record ROI")
)
ts <- shiny::shinyApp(ui, server)
runApp(ts)
return(crpout)
}
89+69
600+97.5+95+90/9
100+97.5+95+90/9
((100*6)+97.5+95+90)/9
.2*158
.3*98.05556
.4*158
+31.6
(.2*69)+(.3*98;05556)+(.2*89)+(.3*99)
(.2*69)+(.3*98.05556)+(.2*89)+(.3*99)
(.2*69)+(.3*98.05556)+(.2*89)+(.3*90)
(.2*69)+(.3*99.05556)+(.2*89)+(.3*90)
(.2*69)+(.3*99.05556)+(.2*89)+(.3*93)
(.2*69)+(.3*98.05556)+(.2*89)+(.3*95)
x1 <- c(8,4,3)
x2 <- c(2,3)
cov(x1,x2)
